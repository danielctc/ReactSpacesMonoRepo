rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow admin access to everything
    match /{document=**} {
      allow read, write: if isDisruptiveAdmin();
    }
    
    // Allow users to read and write their own profile records
    match /users/{userId} {
      // Allow users to read/write their own PUBLIC profile data
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow any authenticated user to read PUBLIC profile data
      allow read: if request.auth != null;
      
      // Special rule to allow username availability checking during registration
      // This allows checking username field without authentication
      allow list: if true;

      // Allow updates for group memberships (if only 'groups' field changes on the main doc)
      // Admins can update via the global rule.
      allow update: if request.auth != null && request.auth.uid == userId && 
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['groups']);

      // --- Rule for private subcollection ---
      match /private/{privateDocId} {
        // Allow ONLY the user themselves or an admin to read/write private data
        allow read, write: if request.auth != null && (request.auth.uid == userId || isDisruptiveAdmin());
      }
    }
    
    // Allow access to groups based on membership
    match /groups/{groupId} {
      allow read: if isGroupMember(groupId) || isDisruptiveAdmin();
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to spaces - public access for spaces marked as public
    match /spaces/{spaceId} {
      // Allow public read access to spaces explicitly marked as public,
      // or allow authenticated users based on additional access rules
      allow read: if true
      // Allow write access only to the space owner or an admin
      allow write: if isSpaceOwner(spaceId) || isDisruptiveAdmin();
      
      // Allow access to portals within spaces
      match /portals/{portalId} {
        // Allow any authenticated user to read portals
        allow read: if request.auth != null;
        // Allow write access only to space owners or admins
        allow write: if isSpaceOwner(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to media screens within spaces
      match /mediaScreens/{screenId} {
        // Allow public read access only for public spaces
        allow read: if isSpacePublic(spaceId) || request.auth != null;
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to media screen images
      match /mediaScreenImages/{imageId} {
        // Allow public read access only for public spaces
        allow read: if isSpacePublic(spaceId) || request.auth != null;
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to media screen thumbnails
      match /mediaScreenThumbnails/{thumbnailId} {
        // Allow public read access only for public spaces
        allow read: if isSpacePublic(spaceId) || request.auth != null;
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to space objects
      match /objects/{objectId} {
        // Allow any authenticated user to read objects
        allow read: if request.auth != null;
        // Allow write access only to space owners, hosts, or admins
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to catalogue items within spaces
      match /catalogue/{itemId} {
        // Allow any authenticated user to read catalogue items
        allow read: if request.auth != null;
        // Allow write access only to space owners or admins
        allow write: if isSpaceOwner(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to analytics collections
      match /analyticsEvents/{eventId} {
        // Only allow server-side (Cloud Functions) access for analytics events
        allow read, write: if false;
      }
      
      match /analyticsSessions/{sessionId} {
        // Only allow server-side (Cloud Functions) access for analytics sessions
        allow read, write: if false;
      }
      
      // Note: dedup collection is accessed only by Cloud Functions (admin privileges)
      // No client access rules needed
    }
    
    // Allow website components read (PUBLIC)
    match /website/{websiteId} {
      allow read: if true;
    }
    
    // Allow public read access to brands, but only admin write access
    match /brands/{brandId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow public read access to events, but only admin write access
    match /events/{eventId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow all authenticated users to read WebGL builds, and public access for builds used in public spaces
    match /webglBuilds/{buildId} {
      allow read: if isWebGLBuildPublic(buildId) || request.auth != null;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to chat messages for spaces - keep these private
    match /chatMessages/{messageId} {
      // Ensure chat message access is limited to relevant spaces
      allow read: if request.auth != null && 
                   (resource.data.spaceId == null || 
                    isSpaceOwnerOrHost(resource.data.spaceId) || 
                    isSpacePublic(resource.data.spaceId));
      allow write: if request.auth != null && 
                    (request.resource.data.spaceId == null || 
                     isSpaceOwnerOrHost(request.resource.data.spaceId));
    }
    
    // Allow access to media screens collection at root level
    match /mediaScreens/{screenId} {
      allow read: if request.auth != null;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to media screen images collection at root level
    match /mediaScreenImages/{imageId} {
      allow read: if request.auth != null;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to media screen thumbnails collection at root level
    match /mediaScreenThumbnails/{thumbnailId} {
      allow read: if request.auth != null;
      allow write: if isDisruptiveAdmin();
    }
    
    // Helper functions
    function isDisruptiveAdmin() {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny(['disruptiveAdmin']);
    }
    
    function isGroupMember(groupId) {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny([groupId]);
    }
    
    function isSpaceOwner(spaceId) {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny(['space_' + spaceId + '_owners']);
    }
    
    function isSpaceHost(spaceId) {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny(['space_' + spaceId + '_hosts']);
    }
    
    function isSpaceOwnerOrHost(spaceId) {
      return isSpaceOwner(spaceId) || isSpaceHost(spaceId);
    }
    
    function isSpacePublic(spaceId) {
      return get(/databases/$(database)/documents/spaces/$(spaceId)).data.isPublic == true;
    }
    
    function isSpaceAccessibleToAll(spaceId) {
      return request.auth != null && get(/databases/$(database)/documents/spaces/$(spaceId)).data.accessibleToAllUsers == true;
    }
    
    // Check if a WebGL build is used in a public space
    function isWebGLBuildPublic(buildId) {
      return exists(/databases/$(database)/documents/spaces/{spaceId}) 
             && get(/databases/$(database)/documents/spaces/{spaceId}).data.webglBuildId == buildId
             && get(/databases/$(database)/documents/spaces/{spaceId}).data.isPublic == true;
    }
  }
}
