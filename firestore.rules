rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow admin access to everything
    match /{document=**} {
      allow read, write: if isDisruptiveAdmin();
    }
    
    // Allow users to read and write their own profile records
    match /users/{userId} {
      // SECURITY: Allow individual profile reads (get) for social features
      // This allows guests and users to see profiles, avatars, usernames
      allow get: if true;  // âœ… Social feature: View any single profile
      
      // Allow users to read/write their own profile
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow authenticated users to read profiles (for user lists in spaces)
      allow read: if request.auth != null;
      
      // SECURITY: Restrict bulk enumeration - only allow small, targeted queries
      // This prevents scrapers from dumping your entire user database
      // But allows legitimate searches (e.g., "find users in this space")
      allow list: if request.auth != null &&  // Must be authenticated
                     request.query.limit <= 100;  // Max 100 users at a time
      
      // SECURITY: For username checking during registration (unauthenticated)
      // Only allow queries that are clearly for username lookup
      allow list: if !request.auth &&  // Unauthenticated (registration flow)
                     request.query.limit <= 1;  // Only 1 result (availability check)

      // Allow updates for group memberships (if only 'groups' field changes on the main doc)
      // Admins can update via the global rule.
      allow update: if request.auth != null && request.auth.uid == userId && 
                     request.resource.data.diff(resource.data).affectedKeys().hasOnly(['groups']);

      // --- Rule for private subcollection (email, sensitive data) ---
      match /private/{privateDocId} {
        // Allow ONLY the user themselves or an admin to read/write private data
        allow read, write: if request.auth != null && (request.auth.uid == userId || isDisruptiveAdmin());
      }
    }
    
    // Allow access to groups based on membership
    match /groups/{groupId} {
      allow read: if isGroupMember(groupId) || isDisruptiveAdmin();
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to spaces - public access for spaces marked as public
    match /spaces/{spaceId} {
      // SECURITY: Spaces are readable if:
      // 1. Marked as public (isPublic == true)
      // 2. No isPublic field (backward compatibility for existing spaces)
      // 3. Accessible to all users flag is set
      // 4. User is authenticated AND (owner/host/admin)
      
      // Combined read rule (covers both get and list operations)
      allow read: if !('isPublic' in resource.data) ||  // No field = assume public (backward compat)
                     resource.data.isPublic == true ||  // Explicitly public
                     resource.data.accessibleToAllUsers == true ||  // Open to authenticated users
                     (request.auth != null && (
                       isSpaceOwnerOrHost(spaceId) ||  // Owners and hosts
                       isDisruptiveAdmin()  // Admins
                     ));
      
      // Allow write access only to the space owner or an admin
      allow write: if isSpaceOwner(spaceId) || isDisruptiveAdmin();
      
      // Allow access to portals within spaces
      match /portals/{portalId} {
        // Allow public read access for guest users and authenticated users
        allow read: if true;
        // Allow write access only to space owners or admins
        allow write: if isSpaceOwner(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to media screens within spaces
      match /mediaScreens/{screenId} {
        // Allow public read access for guest users and authenticated users
        allow read: if true;
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to media screen images
      match /mediaScreenImages/{imageId} {
        // Allow public read access for guest users and authenticated users
        allow read: if true;
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to media screen thumbnails
      match /mediaScreenThumbnails/{thumbnailId} {
        // Allow public read access for guest users and authenticated users
        allow read: if true;
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to space objects
      match /objects/{objectId} {
        // Allow public read access for guest users and authenticated users
        allow read: if true;
        // Allow write access only to space owners, hosts, or admins
        allow write: if isSpaceOwnerOrHost(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to catalogue items within spaces
      match /catalogue/{itemId} {
        // Allow public read access for guest users and authenticated users
        allow read: if true;
        // Allow write access only to space owners or admins
        allow write: if isSpaceOwner(spaceId) || isDisruptiveAdmin();
      }
      
      // Allow access to chat messages within spaces
      match /chatMessages/{messageId} {
        // Allow authenticated users to read chat messages in any space
        allow read: if request.auth != null;
        // Allow authenticated users to create their own chat messages
        allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
        // Allow users to delete/update only their own messages, or space owners/hosts/admins
        allow update, delete: if request.auth != null && 
                                 (resource.data.uid == request.auth.uid || 
                                  isSpaceOwnerOrHost(spaceId) || 
                                  isDisruptiveAdmin());
      }
      
      // Allow access to analytics collections
      match /analyticsEvents/{eventId} {
        // Only allow server-side (Cloud Functions) access for analytics events
        allow read, write: if false;
      }
      
      match /analyticsSessions/{sessionId} {
        // Only allow server-side (Cloud Functions) access for analytics sessions
        allow read, write: if false;
      }
      
      // Note: dedup collection is accessed only by Cloud Functions (admin privileges)
      // No client access rules needed
    }
    
    // Allow website components read (PUBLIC)
    match /website/{websiteId} {
      allow read: if true;
    }
    
    // Allow public read access to brands, but only admin write access
    match /brands/{brandId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow public read access to events, but only admin write access
    match /events/{eventId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow public read access to WebGL builds for guest users and authenticated users
    match /webglBuilds/{buildId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to chat messages for spaces - keep these private
    match /chatMessages/{messageId} {
      // Ensure chat message access is limited to relevant spaces
      allow read: if request.auth != null && 
                   (resource.data.spaceId == null || 
                    isSpaceOwnerOrHost(resource.data.spaceId) || 
                    isSpacePublic(resource.data.spaceId));
      allow write: if request.auth != null && 
                    (request.resource.data.spaceId == null || 
                     isSpaceOwnerOrHost(request.resource.data.spaceId));
    }
    
    // Allow access to media screens collection at root level
    match /mediaScreens/{screenId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to media screen images collection at root level
    match /mediaScreenImages/{imageId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Allow access to media screen thumbnails collection at root level
    match /mediaScreenThumbnails/{thumbnailId} {
      allow read: if true;
      allow write: if isDisruptiveAdmin();
    }
    
    // Helper functions
    function isDisruptiveAdmin() {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny(['disruptiveAdmin']);
    }
    
    function isGroupMember(groupId) {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny([groupId]);
    }
    
    function isSpaceOwner(spaceId) {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny(['space_' + spaceId + '_owners']);
    }
    
    function isSpaceHost(spaceId) {
      return request.auth != null 
             && request.auth.token.groups != null 
             && request.auth.token.groups.hasAny(['space_' + spaceId + '_hosts']);
    }
    
    function isSpaceOwnerOrHost(spaceId) {
      return isSpaceOwner(spaceId) || isSpaceHost(spaceId);
    }
    
    function isSpacePublic(spaceId) {
      return get(/databases/$(database)/documents/spaces/$(spaceId)).data.isPublic == true;
    }
    
    function isSpaceAccessibleToAll(spaceId) {
      return request.auth != null && get(/databases/$(database)/documents/spaces/$(spaceId)).data.accessibleToAllUsers == true;
    }
    
    // Check if a WebGL build is used in a public space
    function isWebGLBuildPublic(buildId) {
      return exists(/databases/$(database)/documents/spaces/{spaceId}) 
             && get(/databases/$(database)/documents/spaces/{spaceId}).data.webglBuildId == buildId
             && get(/databases/$(database)/documents/spaces/{spaceId}).data.isPublic == true;
    }
  }
}
